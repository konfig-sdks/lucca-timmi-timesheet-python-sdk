# coding: utf-8

"""
    Timmi Timesheet API

    Welcome on the documentation for the Timmi Timesheet API. 

    The version of the OpenAPI document: 1.0
    Contact: developers@lucca.fr
    Created by: https://www.lucca.fr
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from lucca_timmi_timesheet_python_sdk import schemas  # noqa: F401


class TimeEntry(
    schemas.DictSchema
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)

    TimeEntries are the working time sequences spent by a user on any given day.

These ressources are exposed in the `/api/v3/timeentries` endpoint.

TimeEntries come in different **units** and **submission modes**.

## About units & duration

Timmi Timesheet supports up to 3 different units when it comes to entering TimeEntries. These are:
- `0: Days` In this case, the user does not enter the exact hours he/she started working, but rather the total duration spent as a fraction of a day. For example: "John worked half a day on Monday".
- `1: Hours` In this case, the user still does not enter the exact hours, but only the duration spent in hours. For example: "John worked 7h30min yesterday".
- `2: Time` In this unit, the user has to enter the actual time he/she started working, as well as the end time. For example: "John started working at 08:00 for 3 hours, thus ending at 11:00".

```csharp
enum TimeEntryUnit:
{
    Days = 0,
    Hours = 1,
    Time = 2
}
```

Whichever the unit, the TimeEntry is mainly determined by three properties:
- `(int) ownerId`: The user it belongs to.
- `(date-time) startsAt`: The date and time when the user started working. In `Days` and `Hours` units, the time part can only be `00:00:00` for "morning" (AM) or `12:00:00` for the "afternoon" (PM).
- `(duration) duration`: The total time spent by the user from the time he/she started. In all units, this property is serialized as a string compliant with the Timespan formating: `d.hh:mm:ss` where `d` is the number of days (can be omitted if equal to zero which is in most cases), `hh` the number of hours, `mm` the number of minutes, and `ss` the number of seconds.

<!-- theme: warning -->
> #### StartsAt and timezones
> The `startsAt` date-time property must be considered a [floating](https://www.w3.org/International/wiki/FloatingTime) date-time. As such, no UTC offset should be sent when creating or editing a TimeEntry.

<!-- theme: warning -->
> #### Max duration
> A TimeEntry cannot have a duration longer than 24h00 (ie one full day). 

Some examples :
```js
// TIME UNIT
// Case: "John (id: 416) worked between 09:45 and 12:15 on January, 1st 2021."
var timeEntry = {
  "ownerId": 416,
  "startsAt": "2021-01-01 09:45:00",
  "duration: "02:30:00",
  "unit": 2
};

// HOURS UNIT
// Case: "John (id: 416) spent 4h45min working on January, 1st 2021 in the morning"
var timeEntry = {
  "ownerId": 416,
  "startsAt": "2021-01-01 00:00:00",
  "duration: "04:45:00",
  "unit": 1
}

// DAYS UNIT
// Case: "John (id: 416) worked on the afternoon of January, 1st 2021"
var timeEntry = {
  "ownerId": 416,
  "startsAt": "2021-01-01 12:00:00",
  "duration: "12:00:00",
  "unit": 0
}
```

## About submission modes

There are 2 submission modes in Timmi Timesheet:
- **Attendance**: the user is expected to enter the sequences of work without much detail.
- **Activities**: the user is expected to enter the time spent on each task / project / whatever.

Therefore, TimeEntries in activities mode have a supplementary property: the set of task / project / cost center / ... the user worked on. These analytical items are called AxisSections. [More info here](docs/General/Resources/010.AxisSection.md).


```json
{
  "ownerId": 416,
  "startsAt": "2021-01-01 00:00:00",
  "duration: "04:45:00",
  "unit": 1,
  "axisSections": [
    {
      "name": "R&D",
      "axis": {
        "name": "Cost centers"
      }
    },
    {
      "name": "My awesome project",
      "axis": {
        "name": "Projects"
      }
    },
    {
      "name": "Testing",
      "axis": {
        "name": "Tasks"
      }
    }
  ]
}
```

## About time types
Each time-entry can reference a time type via its `timeTypeId` property.

Time types are a configured working time classification. It is generally used as a way of discriminating different types of working hours regarding compensation:
- Attendance
- Travels
- etc...

Time types can only be used on users that belong to a specific regulation (ie time and attendance policy) mode: `timeTrackingMode: typed`. Whenever it is not the case, the `timeTypeId` property should be left `null`.

## Fields
    """


    class MetaOapg:
        required = {
            "duration",
            "unit",
            "startsAt",
            "ownerId",
        }
        
        class properties:
            startsAt = schemas.DateTimeSchema
            duration = schemas.StrSchema
            
            
            class unit(
                schemas.EnumBase,
                schemas.IntSchema
            ):
                
                @schemas.classproperty
                def POSITIVE_0(cls):
                    return cls(0)
                
                @schemas.classproperty
                def POSITIVE_1(cls):
                    return cls(1)
                
                @schemas.classproperty
                def POSITIVE_2(cls):
                    return cls(2)
            
            
            class ownerId(
                schemas.IntSchema
            ):
                pass
            
            
            class id(
                schemas.IntSchema
            ):
                pass
            endsAt = schemas.DateTimeSchema
            authorId = schemas.IntSchema
            createdAt = schemas.DateTimeSchema
            
            
            class creationSource(
                schemas.EnumBase,
                schemas.IntSchema
            ):
                
                @schemas.classproperty
                def POSITIVE_0(cls):
                    return cls(0)
                
                @schemas.classproperty
                def POSITIVE_1(cls):
                    return cls(1)
                
                @schemas.classproperty
                def POSITIVE_2(cls):
                    return cls(2)
                
                @schemas.classproperty
                def POSITIVE_3(cls):
                    return cls(3)
            modifierId = schemas.IntSchema
            modifiedAt = schemas.IntSchema
            layer = schemas.IntSchema
            
            
            class axisSections(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['AxisSection']:
                        return AxisSection
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple['AxisSection'], typing.List['AxisSection']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'axisSections':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'AxisSection':
                    return super().__getitem__(i)
            
            
            class comment(
                schemas.AnyTypeSchema,
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        content = schemas.StrSchema
                        authorId = schemas.IntSchema
                        createdAt = schemas.DateTimeSchema
                        __annotations__ = {
                            "content": content,
                            "authorId": authorId,
                            "createdAt": createdAt,
                        }
            
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["content"]) -> MetaOapg.properties.content: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["authorId"]) -> MetaOapg.properties.authorId: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["createdAt"]) -> MetaOapg.properties.createdAt: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["content", "authorId", "createdAt", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["content"]) -> typing.Union[MetaOapg.properties.content, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["authorId"]) -> typing.Union[MetaOapg.properties.authorId, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["createdAt"]) -> typing.Union[MetaOapg.properties.createdAt, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["content", "authorId", "createdAt", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    content: typing.Union[MetaOapg.properties.content, str, schemas.Unset] = schemas.unset,
                    authorId: typing.Union[MetaOapg.properties.authorId, decimal.Decimal, int, schemas.Unset] = schemas.unset,
                    createdAt: typing.Union[MetaOapg.properties.createdAt, str, datetime, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'comment':
                    return super().__new__(
                        cls,
                        *args,
                        content=content,
                        authorId=authorId,
                        createdAt=createdAt,
                        _configuration=_configuration,
                        **kwargs,
                    )
            timeTypeId = schemas.AnyTypeSchema
            __annotations__ = {
                "startsAt": startsAt,
                "duration": duration,
                "unit": unit,
                "ownerId": ownerId,
                "id": id,
                "endsAt": endsAt,
                "authorId": authorId,
                "createdAt": createdAt,
                "creationSource": creationSource,
                "modifierId": modifierId,
                "modifiedAt": modifiedAt,
                "layer": layer,
                "axisSections": axisSections,
                "comment": comment,
                "timeTypeId": timeTypeId,
            }
    
    duration: MetaOapg.properties.duration
    unit: MetaOapg.properties.unit
    startsAt: MetaOapg.properties.startsAt
    ownerId: MetaOapg.properties.ownerId
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["startsAt"]) -> MetaOapg.properties.startsAt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["unit"]) -> MetaOapg.properties.unit: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ownerId"]) -> MetaOapg.properties.ownerId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["endsAt"]) -> MetaOapg.properties.endsAt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["authorId"]) -> MetaOapg.properties.authorId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["createdAt"]) -> MetaOapg.properties.createdAt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["creationSource"]) -> MetaOapg.properties.creationSource: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["modifierId"]) -> MetaOapg.properties.modifierId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["modifiedAt"]) -> MetaOapg.properties.modifiedAt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["layer"]) -> MetaOapg.properties.layer: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["axisSections"]) -> MetaOapg.properties.axisSections: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["comment"]) -> MetaOapg.properties.comment: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["timeTypeId"]) -> MetaOapg.properties.timeTypeId: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["startsAt", "duration", "unit", "ownerId", "id", "endsAt", "authorId", "createdAt", "creationSource", "modifierId", "modifiedAt", "layer", "axisSections", "comment", "timeTypeId", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["startsAt"]) -> MetaOapg.properties.startsAt: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["unit"]) -> MetaOapg.properties.unit: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ownerId"]) -> MetaOapg.properties.ownerId: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["endsAt"]) -> typing.Union[MetaOapg.properties.endsAt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["authorId"]) -> typing.Union[MetaOapg.properties.authorId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["createdAt"]) -> typing.Union[MetaOapg.properties.createdAt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["creationSource"]) -> typing.Union[MetaOapg.properties.creationSource, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["modifierId"]) -> typing.Union[MetaOapg.properties.modifierId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["modifiedAt"]) -> typing.Union[MetaOapg.properties.modifiedAt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["layer"]) -> typing.Union[MetaOapg.properties.layer, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["axisSections"]) -> typing.Union[MetaOapg.properties.axisSections, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["comment"]) -> typing.Union[MetaOapg.properties.comment, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["timeTypeId"]) -> typing.Union[MetaOapg.properties.timeTypeId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["startsAt", "duration", "unit", "ownerId", "id", "endsAt", "authorId", "createdAt", "creationSource", "modifierId", "modifiedAt", "layer", "axisSections", "comment", "timeTypeId", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        duration: typing.Union[MetaOapg.properties.duration, str, ],
        unit: typing.Union[MetaOapg.properties.unit, decimal.Decimal, int, ],
        startsAt: typing.Union[MetaOapg.properties.startsAt, str, datetime, ],
        ownerId: typing.Union[MetaOapg.properties.ownerId, decimal.Decimal, int, ],
        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        endsAt: typing.Union[MetaOapg.properties.endsAt, str, datetime, schemas.Unset] = schemas.unset,
        authorId: typing.Union[MetaOapg.properties.authorId, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        createdAt: typing.Union[MetaOapg.properties.createdAt, str, datetime, schemas.Unset] = schemas.unset,
        creationSource: typing.Union[MetaOapg.properties.creationSource, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        modifierId: typing.Union[MetaOapg.properties.modifierId, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        modifiedAt: typing.Union[MetaOapg.properties.modifiedAt, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        layer: typing.Union[MetaOapg.properties.layer, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        axisSections: typing.Union[MetaOapg.properties.axisSections, list, tuple, schemas.Unset] = schemas.unset,
        comment: typing.Union[MetaOapg.properties.comment, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        timeTypeId: typing.Union[MetaOapg.properties.timeTypeId, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'TimeEntry':
        return super().__new__(
            cls,
            *args,
            duration=duration,
            unit=unit,
            startsAt=startsAt,
            ownerId=ownerId,
            id=id,
            endsAt=endsAt,
            authorId=authorId,
            createdAt=createdAt,
            creationSource=creationSource,
            modifierId=modifierId,
            modifiedAt=modifiedAt,
            layer=layer,
            axisSections=axisSections,
            comment=comment,
            timeTypeId=timeTypeId,
            _configuration=_configuration,
            **kwargs,
        )

from lucca_timmi_timesheet_python_sdk.model.axis_section import AxisSection
